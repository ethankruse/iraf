
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>iraf.noao.imred.ccdred.combine &#8212; AIRAF 1.0 documentation</title>
    <link rel="stylesheet" href="../../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for iraf.noao.imred.ccdred.combine</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">iraf.utils</span> <span class="k">import</span> <span class="n">file_handler</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">iraf.sys</span> <span class="k">import</span> <span class="n">image_open</span><span class="p">,</span> <span class="n">image_close</span>
<span class="kn">import</span> <span class="nn">re</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;combine&#39;</span><span class="p">,</span> <span class="s1">&#39;Instrument&#39;</span><span class="p">,</span> <span class="s1">&#39;ccdtypes&#39;</span><span class="p">,</span> <span class="s1">&#39;get_header_value&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="Instrument"><a class="viewcode-back" href="../../../../../index.html#iraf.noao.imred.ccdred.combine.Instrument">[docs]</a><span class="k">class</span> <span class="nc">Instrument</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instrument object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To learn about instruments, look into</span>
<span class="sd">    &#39;iraf-src/noao/imred/ccdred/src/hdrmap.x&#39; for the functions that create</span>
<span class="sd">    a symbol table pointer and do the translations.</span>
<span class="sd">    Instrument file tables are located in</span>
<span class="sd">    &#39;iraf-src/noao/imred/ccdred/ccddb&#39;.</span>

<span class="sd">    values in fits headers/etc actually used so far:</span>
<span class="sd">    imagetyp </span>
<span class="sd">    and its header values: object|zero|dark|flat|illum|fringe|other|comp</span>
<span class="sd">    and also none, unknown.</span>
<span class="sd">    subset</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># XXX: need to handle allowing &#39;default&#39; values for things</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">definitions</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="c1"># insert how to interpret things</span>
            <span class="c1"># XXX: filter or filters?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">definitions</span><span class="p">[</span><span class="s1">&#39;subset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;filter&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">definitions</span><span class="p">[</span><span class="s1">&#39;bias&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;zero&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">definitions</span><span class="p">[</span><span class="s1">&#39;dome flat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;flat&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">definitions</span><span class="p">[</span><span class="s1">&#39;projector flat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;flat&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">definitions</span><span class="p">[</span><span class="s1">&#39;comparison&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;comp&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">definitions</span><span class="p">[</span><span class="s1">&#39;sky flat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;object&#39;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Instrument </span><span class="si">{name}</span><span class="s1"> not implemented yet.&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="Instrument.translate"><a class="viewcode-back" href="../../../../../index.html#iraf.noao.imred.ccdred.combine.Instrument.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># if it&#39;s a string, strip the value and put it in lowercase.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">definitions</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">definitions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set up an Instrument class with a translate() function or something.</span>
<span class="sd">    Maybe more like to_default() or from_default() </span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<span class="k">def</span> <span class="nf">make_fits</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="n">splits</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">splits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;fits&#39;</span><span class="p">,</span> <span class="s1">&#39;fit&#39;</span><span class="p">]:</span>
        <span class="n">path</span> <span class="o">+=</span> <span class="s1">&#39;.fits&#39;</span>
    <span class="k">return</span> <span class="n">path</span>


<span class="k">def</span> <span class="nf">set_header_value</span><span class="p">(</span><span class="n">hdulist</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The equivalent of IRAF&#39;s hdmput*. (e.g. hdmputi, hdmputr)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hdulist</span>
<span class="sd">    instrument</span>
<span class="sd">    key</span>
<span class="sd">    value</span>
<span class="sd">    comment</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># what is the header key in the instrument&#39;s language</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">instrument</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="c1"># go through the list of hdus</span>
    <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">hdu</span> <span class="ow">in</span> <span class="n">hdulist</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
            <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span>
    <span class="c1"># if it&#39;s not in any headers, put it in the first one</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
        <span class="n">hdulist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span>
    <span class="k">return</span>


<div class="viewcode-block" id="get_header_value"><a class="viewcode-back" href="../../../../../index.html#iraf.noao.imred.ccdred.combine.get_header_value">[docs]</a><span class="k">def</span> <span class="nf">get_header_value</span><span class="p">(</span><span class="n">hdulist</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The equivalent of IRAF&#39;s hdmg*. (e.g. hdmgstr)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hdulist</span>
<span class="sd">    instrument</span>
<span class="sd">    key</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># what is the header key in the instrument&#39;s language</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">instrument</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># go reverse order because we&#39;ll typically want the first instance</span>
    <span class="c1"># if something is in multiple headers</span>
    <span class="k">for</span> <span class="n">hdu</span> <span class="ow">in</span> <span class="n">hdulist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># get the instrument&#39;s value in the header</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="c1"># translate that back to our normalized language</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">instrument</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># XXX: we need a way to use a default value here if given in the</span>
        <span class="c1"># instrument object</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="ccdtypes"><a class="viewcode-back" href="../../../../../index.html#iraf.noao.imred.ccdred.combine.ccdtypes">[docs]</a><span class="k">def</span> <span class="nf">ccdtypes</span><span class="p">(</span><span class="n">hdulist</span><span class="p">,</span> <span class="n">instrument</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the header value of &#39;imagetyp&#39; (or instrument equivalent).</span>
<span class="sd">    If that (instrument converted) value is one of</span>
<span class="sd">    &quot;object|zero|dark|flat|illum|fringe|other|comp&quot; return that.</span>
<span class="sd">    Otherwise return &#39;unknown&#39; unless the header does not contain any</span>
<span class="sd">    &#39;imagetyp&#39; and the instrument doesn&#39;t have a default value for it. Then</span>
<span class="sd">    return &#39;none&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hdulist</span>
<span class="sd">    instrument : Instrument</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="n">Instrument</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ccdtypes not given an Instrument object.&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">options</span> <span class="o">=</span> <span class="s2">&quot;object|zero|dark|flat|illum|fringe|other|comp&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span>
    <span class="n">typ</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">hdulist</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;imagetyp&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">typ</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
    <span class="k">elif</span> <span class="n">typ</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="s1">&#39;unknown&#39;</span>

    <span class="k">return</span> <span class="n">typ</span></div>


<span class="k">def</span> <span class="nf">ccdsubset</span><span class="p">(</span><span class="n">hdulist</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">ssfile</span><span class="p">):</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="n">Instrument</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ccdsubset not given an Instrument object.&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">subsetstr</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">hdulist</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">subsetstr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">subsetstr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="n">subsetstr</span> <span class="o">=</span> <span class="n">subsetstr</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="c1"># Replace non alphanumeric or &#39;.&#39; characters by &#39;_&#39;</span>
    <span class="c1"># since the subset ID is used in forming image names.</span>
    <span class="n">subsetstr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[^\w.]&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">subsetstr</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # This bit was a translation of the original IRAF ccdsubset function</span>
<span class="sd">    # that uses the subsets file and turns things into shorter subset strings</span>
<span class="sd">    # while also making sure there aren&#39;t overlaps. This all seems unnecessary</span>
<span class="sd">    # and we should just use the full subset string as the identifier.</span>

<span class="sd">    import shlex</span>
<span class="sd">    </span>
<span class="sd">    if ssfile is None:</span>
<span class="sd">        print(&#39;ssfile must be defined to use subsets&#39;)</span>
<span class="sd">        sys.exit(1)</span>
<span class="sd">        </span>
<span class="sd">    # The default subset identifier is the first</span>
<span class="sd">    # word/string of the subset string.</span>
<span class="sd">    subset1 = shlex.split(subsetstr.strip())</span>
<span class="sd">    if len(subset1) &gt; 0:</span>
<span class="sd">        subset1 = subset1[0]</span>
<span class="sd">    else:</span>
<span class="sd">        subset1 = None</span>

<span class="sd">    # A null subset string is ok.  If not null check for conflict</span>
<span class="sd">    # with previous subset IDs.</span>

<span class="sd">    if subset1 is not None:</span>
<span class="sd">        orig = subset1</span>
<span class="sd">        # whether or not to append this to the subsets file</span>
<span class="sd">        append = True</span>
<span class="sd">        # Search the subset record file for the same subset string.</span>
<span class="sd">        # If found use the ID string.  If the subset ID has been</span>
<span class="sd">        # used for another subset string then increment an integer</span>
<span class="sd">        # suffix to the default ID and check the list again.</span>
<span class="sd">        if os.path.exists(ssfile):</span>
<span class="sd">            subsetstrs = []</span>
<span class="sd">            subsetids = []</span>
<span class="sd">            with open(ssfile, &#39;r&#39;) as ff:</span>
<span class="sd">                lines = ff.readlines()</span>
<span class="sd">                for row in lines:</span>
<span class="sd">                    # skip over blank lines and comment lines</span>
<span class="sd">                    if (len(row) == 0 or len(row.strip()) == 0 or</span>
<span class="sd">                            row[0].strip()[0] == &#39;#&#39;):</span>
<span class="sd">                        continue</span>

<span class="sd">                    groups = shlex.strip(row)</span>
<span class="sd">                    assert len(groups) == 2</span>
<span class="sd">                    subsetstrs.append(groups[0])</span>
<span class="sd">                    subsetids.append(groups[1])</span>

<span class="sd">            ii = 1</span>
<span class="sd">            while True:</span>
<span class="sd">                if subsetstr in subsetstrs:</span>
<span class="sd">                    append = False</span>
<span class="sd">                    subset1 = subsetids[subsetstrs.index(subsetstr)]</span>
<span class="sd">                    break</span>
<span class="sd">                else:</span>
<span class="sd">                    if subset1 in subsetids:</span>
<span class="sd">                        subset1 = &#39;{0}{1:d}&#39;.format(orig, ii)</span>
<span class="sd">                        ii += 1</span>
<span class="sd">                    else:</span>
<span class="sd">                        break</span>

<span class="sd">        if append:</span>
<span class="sd">            with open(ssfile, &#39;a&#39;) as ff:</span>
<span class="sd">                ff.write(&#39;{0}\t{1}\n&#39;.format(subsetstr, subset1))</span>

<span class="sd">        # Set the subset ID string and replace magic characters by &#39;_&#39;</span>
<span class="sd">        # since the subset ID is used in forming image names.</span>
<span class="sd">        for ii, ichar in enumerate(subset1):</span>
<span class="sd">            if not ichar.isalnum() and ichar != &#39;.&#39;:</span>
<span class="sd">                subset1[ii] = &#39;_&#39;</span>

<span class="sd">    return subset1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">subsetstr</span>


<span class="k">def</span> <span class="nf">ic_setout</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">nimages</span><span class="p">,</span> <span class="n">project</span><span class="p">,</span> <span class="n">offsets</span><span class="p">):</span>

    <span class="n">indim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">outdim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">project</span><span class="p">:</span>
        <span class="n">outdim</span> <span class="o">=</span> <span class="n">indim</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># XXX: IM_NDIM(out[1]) = outdim</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="n">outdim</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Image dimensions are not the same&quot;</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # Set the reference point to that of the first image.</span>
<span class="sd">    # Open an MWCS descriptor on an image</span>
<span class="sd">    mw = mw_openim (in[1])</span>
<span class="sd">    # Get the value of a MWCS interface parameter.</span>
<span class="sd">    mwdim = mw_stati (mw, MW_NPHYSDIM)</span>
<span class="sd">    # Get the linear part of the Wterm, i.e., the physical and world</span>
<span class="sd">    # coordinates of the reference point and the CD matrix.</span>
<span class="sd">    call mw_gwtermd (mw, Memd[lref], Memd[wref], Memd[cd], mwdim)</span>
<span class="sd">    # Set up a coordinate transformation (CTRAN) descriptor.</span>
<span class="sd">    ct = mw_sctran (mw, &quot;world&quot;, &quot;logical&quot;, 0)</span>
<span class="sd">    # Transform a single N-dimensional point</span>
<span class="sd">    call mw_ctrand (ct, Memd[wref], Memd[lref], mwdim)</span>
<span class="sd">    call mw_ctfree (ct)</span>
<span class="sd">    if (project)</span>
<span class="sd">        Memd[lref+outdim] = 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Parse the user offset string.  If &quot;none&quot; then there are no offsets.</span>
    <span class="c1"># If &quot;wcs&quot; then set the offsets based on the image WCS.</span>
    <span class="c1"># If &quot;grid&quot; then set the offsets based on the input grid parameters.</span>
    <span class="c1"># If a file scan it.</span>
    <span class="k">if</span> <span class="n">offsets</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="n">offsetsarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nimages</span><span class="p">,</span> <span class="n">outdim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">reloff</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># XXX: implement these</span>
    <span class="k">elif</span> <span class="n">offsets</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;wcs&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WCS offsets not implemented yet.&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">offsets</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;grid offsets not implemented yet.&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Manual file offsets not implemented yet.&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">aligned</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">outdim</span><span class="p">):</span>
        <span class="n">aa</span> <span class="o">=</span> <span class="n">offsetsarr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">+</span> <span class="n">aa</span>
        <span class="n">amin</span> <span class="o">=</span> <span class="n">aa</span>
        <span class="n">bmax</span> <span class="o">=</span> <span class="n">bb</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nimages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">aa</span> <span class="o">=</span> <span class="n">offsetsarr</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
            <span class="n">bb</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">+</span> <span class="n">aa</span>
            <span class="k">if</span> <span class="n">aa</span> <span class="o">!=</span> <span class="n">amin</span> <span class="ow">or</span> <span class="n">bb</span> <span class="o">!=</span> <span class="n">bmax</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">reloff</span><span class="p">:</span>
                <span class="n">aligned</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">amin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">amin</span><span class="p">)</span>
            <span class="n">bmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">bmax</span><span class="p">)</span>
        <span class="c1"># XXX: also do? IM_LEN(out[1],j) = bmax</span>
        <span class="k">if</span> <span class="n">reloff</span> <span class="ow">or</span> <span class="n">amin</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">offsetsarr</span><span class="p">[:,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">-=</span> <span class="n">amin</span>

            <span class="c1"># XXX: also do? IM_LEN(out[1],j) = IM_LEN(out[1],j) - amin</span>

    <span class="c1"># Update the WCS.</span>
    <span class="c1"># XXX: do this</span>
    <span class="k">if</span> <span class="n">project</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">aligned</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">reloff</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WCS updates to output files not implemented yet!&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">aligned</span><span class="p">,</span> <span class="n">offsetsarr</span>


<span class="c1"># this is meant to be equivalent to immap (output, NEW_COPY, Memi[in]) in IRAF</span>
<span class="k">def</span> <span class="nf">file_new_copy</span><span class="p">(</span><span class="n">outstr</span><span class="p">,</span> <span class="n">in_header</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;NEW_COPY&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">instrument</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;NEW_COPY&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;other modes of file_new_copy not supported.&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Also this only works for FITS files.</span>
    <span class="k">if</span> <span class="n">in_header</span><span class="o">.</span><span class="n">__filetype__</span> <span class="o">==</span> <span class="s1">&#39;fits&#39;</span><span class="p">:</span>
        <span class="n">in_header</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">outstr</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">instrument</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">instrument</span> <span class="o">=</span> <span class="n">Instrument</span><span class="p">()</span>
        <span class="c1"># update header parameters in the new file</span>
        <span class="n">hdulist</span> <span class="o">=</span> <span class="n">image_open</span><span class="p">(</span><span class="n">outstr</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;update&#39;</span><span class="p">)</span>
        <span class="c1"># XXX: update this with a real package name at some point</span>
        <span class="n">orval</span> <span class="o">=</span> <span class="s1">&#39;AIRAF in Python&#39;</span>
        <span class="n">orcomm</span> <span class="o">=</span> <span class="s1">&#39;FITS file originator&#39;</span>
        <span class="n">set_header_value</span><span class="p">(</span><span class="n">hdulist</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="n">orval</span><span class="p">,</span> <span class="n">orcomm</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">datetime</span>
        <span class="n">dtval</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
        <span class="n">dtcomm</span> <span class="o">=</span> <span class="s1">&#39;Date FITS file was generated&#39;</span>
        <span class="n">set_header_value</span><span class="p">(</span><span class="n">hdulist</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="n">dtval</span><span class="p">,</span> <span class="n">dtcomm</span><span class="p">)</span>
        <span class="n">lmcomm</span> <span class="o">=</span> <span class="s1">&#39;Time of last modification&#39;</span>
        <span class="n">set_header_value</span><span class="p">(</span><span class="n">hdulist</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;iraf-tlm&#39;</span><span class="p">,</span> <span class="n">dtval</span><span class="p">,</span> <span class="n">lmcomm</span><span class="p">)</span>
        <span class="n">image_close</span><span class="p">(</span><span class="n">hdulist</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">err</span> <span class="o">=</span> <span class="s1">&#39;file_new_copy of file type </span><span class="si">{0}</span><span class="s1"> not yet implemented.&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">in_header</span><span class="o">.</span><span class="n">__filetype__</span><span class="p">))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span>


<span class="k">def</span> <span class="nf">ic_mopen</span><span class="p">(</span><span class="n">in_images</span><span class="p">,</span> <span class="n">out_images</span><span class="p">,</span> <span class="n">nimages</span><span class="p">,</span> <span class="n">mtype</span><span class="p">,</span> <span class="n">mvalue</span><span class="p">,</span> <span class="n">instrument</span><span class="p">):</span>
    <span class="c1"># MASKTYPES	&quot;|none|goodvalue|badvalue|goodbits|badbits|&quot;</span>
    <span class="n">npix</span> <span class="o">=</span> <span class="n">out_images</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # pointer to pms and bufs for each input image</span>
<span class="sd">    # pms are the pointers to each image&#39;s pixel masks</span>
<span class="sd">    call calloc (pms, nimages, TY_POINTER)</span>
<span class="sd">    # bufs is just an array of 1s of length npix?</span>
<span class="sd">    call calloc (bufs, nimages, TY_POINTER)</span>
<span class="sd">    # for every input image, create an array of ones of length npix</span>
<span class="sd">    do i = 1, nimages {</span>
<span class="sd">        call malloc (Memi[bufs+i-1], npix, TY_INT)</span>
<span class="sd">        call amovki (1, Memi[Memi[bufs+i-1]], npix)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mtype</span> <span class="o">=</span> <span class="n">mtype</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">mtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="s1">&#39;goodvalue&#39;</span><span class="p">,</span> <span class="s1">&#39;badvalue&#39;</span><span class="p">,</span> <span class="s1">&#39;goodbits&#39;</span><span class="p">,</span> <span class="s1">&#39;badbits&#39;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;masktype </span><span class="si">{mtype}</span><span class="s1"> not recognized. Assuming &quot;none&quot;.&#39;</span><span class="p">)</span>
        <span class="n">mtype</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

    <span class="c1"># Check for special cases.  The BOOLEAN type is used when only</span>
    <span class="c1"># zero and nonzero are significant; i.e. the actual mask values are</span>
    <span class="c1"># not important.  The invert flag is used to indicate that</span>
    <span class="c1"># empty masks are all bad rather than all good.</span>
    <span class="k">if</span> <span class="n">mtype</span> <span class="o">==</span> <span class="s1">&#39;badbits&#39;</span> <span class="ow">and</span> <span class="n">mvalue</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">mtype</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
    <span class="k">if</span> <span class="n">mvalue</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;goodvalue&#39;</span><span class="p">,</span> <span class="s1">&#39;goodbits&#39;</span><span class="p">]:</span>
        <span class="n">mtype</span> <span class="o">=</span> <span class="s1">&#39;boolean&#39;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">mvalue</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;badvalue&#39;</span><span class="p">,</span> <span class="s1">&#39;goodbits&#39;</span><span class="p">])</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">mvalue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">mtype</span> <span class="o">==</span> <span class="s1">&#39;goodvalue&#39;</span><span class="p">)):</span>
        <span class="n">invert</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">invert</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># If mask images are to be used, get the mask name from the image</span>
    <span class="c1"># header and open it saving the descriptor in the pms array.</span>
    <span class="c1"># Empty masks (all good) are treated as if there was no mask image.</span>
    <span class="n">npms</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">mtype</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">in_images</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;BPM&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># XXX: implement this</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pixel maps not yet implemented.&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># If no mask images are found and the mask parameters imply that</span>
    <span class="c1"># good values are 0 then use the special case of no masks.</span>
    <span class="k">if</span> <span class="n">npms</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">invert</span><span class="p">:</span>
        <span class="n">mtype</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # Set up mask structure.</span>
<span class="sd">    call calloc (icm, ICM_LEN, TY_STRUCT)</span>
<span class="sd">    ICM_TYPE(icm) = mtype</span>
<span class="sd">    ICM_VALUE(icm) = mvalue</span>
<span class="sd">    ICM_BUFS(icm) = bufs</span>
<span class="sd">    ICM_PMS(icm) = pms</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">mtype</span>


<span class="k">def</span> <span class="nf">type_max</span><span class="p">(</span><span class="n">type1</span><span class="p">,</span> <span class="n">type2</span><span class="p">):</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">type1</span><span class="p">,</span> <span class="n">type2</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;safe&#39;</span><span class="p">)</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">type2</span><span class="p">,</span> <span class="n">type1</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;safe&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">left</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">type1</span>
    <span class="k">if</span> <span class="n">right</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">type2</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # likely case of an unsigned int and signed int of same size</span>
<span class="sd">    ints = [np.int8, np.int16, np.int32, np.int64]</span>
<span class="sd">    if (np.issubdtype(type1.type, np.unsignedinteger) and</span>
<span class="sd">            np.issubdtype(type2.type, np.integer)):</span>
<span class="sd">        for iint in ints:</span>
<span class="sd">            if np.can_cast(type1, iint, casting=&#39;safe&#39;):</span>
<span class="sd">                return np.dtype(iint)</span>

<span class="sd">    elif (np.issubdtype(type2.type, np.unsignedinteger) and</span>
<span class="sd">              np.issubdtype(type1.type, np.integer)):</span>
<span class="sd">        for iint in ints:</span>
<span class="sd">            if np.can_cast(type2, iint, casting=&#39;safe&#39;):</span>
<span class="sd">                return np.dtype(iint)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">errstr</span> <span class="o">=</span> <span class="s2">&quot;Unrecognized dtype or cannot safely cast between </span><span class="si">{0}</span><span class="s2"> and </span><span class="si">{1}</span><span class="s2">.&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">errstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">type1</span><span class="p">,</span> <span class="n">type2</span><span class="p">))</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<div class="viewcode-block" id="combine"><a class="viewcode-back" href="../../../../../index.html#iraf.noao.imred.ccdred.combine.combine">[docs]</a><span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">plfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ccdtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">subsets</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;average&#39;</span><span class="p">,</span>
            <span class="n">reject</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">outtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
            <span class="n">masktype</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">maskvalue</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">blank</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zero</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">statsec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lthreshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hthreshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">nlow</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nhigh</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nkeep</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mclip</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lsigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
            <span class="n">hsigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">rdnoise</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">snoise</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">sigscale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
            <span class="n">pclip</span><span class="o">=-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">grow</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">instrument</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">ssfile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    images :</span>
<span class="sd">        List of images to combine</span>
<span class="sd">    output :</span>
<span class="sd">        List of output images</span>
<span class="sd">    plfile :</span>
<span class="sd">        List of output pixel list files (optional)</span>
<span class="sd">    sigma :</span>
<span class="sd">        List of sigma images (optional)</span>
<span class="sd">    ccdtype  :</span>
<span class="sd">        CCD image type to combine (optional)</span>
<span class="sd">    subsets :</span>
<span class="sd">        Combine images by subset parameter?</span>
<span class="sd">    delete :</span>
<span class="sd">        Delete input images after combining?</span>
<span class="sd">    method : &quot;average|median&quot;</span>
<span class="sd">        Type of combine operation</span>
<span class="sd">    reject : &quot;none|minmax|ccdclip|crreject|sigclip|avsigclip|pclip&quot;</span>
<span class="sd">        Type of rejection</span>
<span class="sd">    project :</span>
<span class="sd">        Project highest dimension of input images?</span>
<span class="sd">    outtype :</span>
<span class="sd">        Output image pixel datatype (e.g. np.float64).</span>
<span class="sd">        Default None gives the output image the datatype of the inputs.</span>
<span class="sd">        Will also revert to the input type if outtype is too low.</span>
<span class="sd">        E.g. inputs have int64 and outtype is int32.</span>
<span class="sd">    offsets :</span>
<span class="sd">        Input image offsets. &#39;none, wcs, grid, or file name&#39;</span>
<span class="sd">    masktype : &quot;none|goodvalue|badvalue|goodbits|badbits&quot;</span>
<span class="sd">        Mask type</span>
<span class="sd">    maskvalue :</span>
<span class="sd">        Mask value</span>
<span class="sd">    blank :</span>
<span class="sd">        Value if there are no pixels</span>
<span class="sd">    scale :</span>
<span class="sd">        Image scaling</span>
<span class="sd">    zero :</span>
<span class="sd">        Image zero point offset</span>
<span class="sd">    weight :</span>
<span class="sd">        Image weights</span>
<span class="sd">    statsec :</span>
<span class="sd">        Image section for computing statistics</span>
<span class="sd">    lthreshold :</span>
<span class="sd">        Lower threshold</span>
<span class="sd">    hthreshold :</span>
<span class="sd">        Upper threshold</span>
<span class="sd">    nlow :</span>
<span class="sd">        minmax: Number of low pixels to reject</span>
<span class="sd">    nhigh :</span>
<span class="sd">        minmax: Number of high pixels to reject</span>
<span class="sd">    nkeep :</span>
<span class="sd">        Minimum to keep (pos) or maximum to reject (neg)</span>
<span class="sd">    mclip :</span>
<span class="sd">        Use median in sigma clipping algorithms?</span>
<span class="sd">    lsigma :</span>
<span class="sd">        Lower sigma clipping factor</span>
<span class="sd">    hsigma :</span>
<span class="sd">        Upper sigma clipping factor</span>
<span class="sd">    rdnoise :</span>
<span class="sd">        ccdclip: CCD readout noise (electrons).</span>
<span class="sd">        Either a number or string of the keyword to pull the number</span>
<span class="sd">        from the image header file.</span>
<span class="sd">    gain :</span>
<span class="sd">        ccdclip: CCD gain (electrons/DN)</span>
<span class="sd">        Either a number or string of the keyword to pull the number</span>
<span class="sd">        from the image header file.</span>
<span class="sd">    snoise :</span>
<span class="sd">        ccdclip: Sensitivity noise (fraction)</span>
<span class="sd">        Either a number or string of the keyword to pull the number</span>
<span class="sd">        from the image header file.</span>
<span class="sd">    sigscale :</span>
<span class="sd">        Tolerance for sigma clipping scaling corrections</span>
<span class="sd">    pclip :</span>
<span class="sd">        Percentile clipping parameter</span>
<span class="sd">    grow :</span>
<span class="sd">        Radius (pixels) for 1D neighbor rejection</span>
<span class="sd">    instrument</span>
<span class="sd">    logfile</span>
<span class="sd">    verbose :</span>
<span class="sd">        Print log information to the standard output?</span>
<span class="sd">    ssfile</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="c1"># was given a string or something else, so set up the instrument object</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="n">Instrument</span><span class="p">):</span>
        <span class="n">instrument</span> <span class="o">=</span> <span class="n">Instrument</span><span class="p">(</span><span class="n">instrument</span><span class="p">)</span>

    <span class="c1"># start of IRAF cmb_images.</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="n">file_handler</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># Go through the input list and eliminate images not satisfying the</span>
    <span class="c1"># CCD image type.  Separate into subsets if desired.  Create image</span>
    <span class="c1"># and subset lists.</span>

    <span class="c1"># lists of images in each subset</span>
    <span class="n">images</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># subset names</span>
    <span class="n">subset</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;average&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Combine method not recognized: </span><span class="si">{method}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
        <span class="c1"># open the image</span>
        <span class="n">hdulist</span> <span class="o">=</span> <span class="n">image_open</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hdulist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># what image type is this one</span>
        <span class="n">thistype</span> <span class="o">=</span> <span class="n">ccdtypes</span><span class="p">(</span><span class="n">hdulist</span><span class="p">,</span> <span class="n">instrument</span><span class="p">)</span>

        <span class="c1"># if this isn&#39;t the image type we&#39;re looking for, skip it</span>
        <span class="k">if</span> <span class="n">ccdtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">thistype</span> <span class="o">!=</span> <span class="n">ccdtype</span><span class="p">:</span>
            <span class="n">image_close</span><span class="p">(</span><span class="n">hdulist</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">subsets</span><span class="p">:</span>
            <span class="n">subsetstr</span> <span class="o">=</span> <span class="n">ccdsubset</span><span class="p">(</span><span class="n">hdulist</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">ssfile</span><span class="p">)</span>
            <span class="c1"># As far as I can tell, the subset and extn list is the same.</span>
            <span class="c1"># extn = subsetstr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subsetstr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="k">if</span> <span class="n">subsetstr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">:</span>
            <span class="n">subset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subsetstr</span><span class="p">)</span>
            <span class="n">images</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">image</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">images</span><span class="p">[</span><span class="n">subset</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">subsetstr</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="n">image_close</span><span class="p">(</span><span class="n">hdulist</span><span class="p">)</span>

    <span class="c1"># end of cmb_images code.</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No images to combine.&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># set threshold flag</span>
    <span class="k">if</span> <span class="n">lthreshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">hthreshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dothresh</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dothresh</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">lthreshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lthreshold</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">if</span> <span class="n">hthreshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hthreshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="c1"># get copies of these before adding to them for each subset</span>
    <span class="n">outroot</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">plfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plroot</span> <span class="o">=</span> <span class="n">plfile</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plroot</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigroot</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sigroot</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># XXX: make sure we&#39;re not changing input values in each loop.</span>
    <span class="c1"># Combine each input subset.</span>
    <span class="k">for</span> <span class="n">zz</span><span class="p">,</span> <span class="n">iset</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subset</span><span class="p">):</span>

        <span class="n">iimages</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">zz</span><span class="p">]</span>

        <span class="c1"># this apparently isn&#39;t done in IRAF, but I like separating the two</span>
        <span class="c1"># parts with a &#39;.&#39; if they both exist</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">comb</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comb</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="n">base</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">outroot</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{base}{comb}{iset}{ext}</span><span class="s1">&#39;</span>

        <span class="k">if</span> <span class="n">plroot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">plroot</span><span class="p">)</span>
            <span class="n">plfile</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{base}{comb}{iset}{ext}</span><span class="s1">&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plfile</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">sigroot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">sigroot</span><span class="p">)</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{base}{comb}{iset}{ext}</span><span class="s1">&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># icombine starts here</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # Combine all images from the (subset) list.</span>
<span class="sd">        call icombine (Memc[Memi[images+i-1]], Memi[nimages+i-1],</span>
<span class="sd">        Memc[output], Memc[plfile], Memc[sigma],</span>
<span class="sd">        Memc[logfile], NO, delete))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set number of images to combine.</span>
        <span class="k">if</span> <span class="n">project</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iimages</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot project combine a list of images&quot;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">hdulist</span> <span class="o">=</span> <span class="n">image_open</span><span class="p">(</span><span class="n">iimages</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">shp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hdulist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">image_close</span><span class="p">(</span><span class="n">hdulist</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">shp</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">shp</span><span class="p">[</span><span class="n">shp</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can&#39;t project one dimensional images&quot;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="c1"># XXX: which dimension do we project over?</span>
            <span class="n">nimages</span> <span class="o">=</span> <span class="n">shp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nimages</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iimages</span><span class="p">)</span>

        <span class="c1"># Convert the nkeep parameter if needed.</span>
        <span class="c1"># XXX: do we want to do this here or wait until later?</span>
        <span class="k">if</span> <span class="n">nkeep</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nkeep</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nimages</span> <span class="o">+</span> <span class="n">nkeep</span><span class="p">)</span>

        <span class="c1"># Convert the pclip parameter to a number of pixels rather than</span>
        <span class="c1"># a fraction.  This number stays constant even if pixels are</span>
        <span class="c1"># rejected.  The number of low and high pixel rejected, however,</span>
        <span class="c1"># are converted to a fraction of the valid pixels.</span>

        <span class="n">reject</span> <span class="o">=</span> <span class="n">reject</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">rejectopts</span> <span class="o">=</span> <span class="s2">&quot;none|ccdclip|crreject|minmax|pclip|sigclip|avsigclip&quot;</span>
        <span class="k">if</span> <span class="n">reject</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rejectopts</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Could not recognize reject parameter </span><span class="si">{reject}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># define	REJECT	&quot;|none|ccdclip|crreject|minmax|pclip|sigclip|avsigclip|&quot;</span>
        <span class="k">if</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;pclip&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pclip</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Pclip parameter can not be zero when reject==&#39;pclip&#39;&quot;</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="n">ii</span> <span class="o">=</span> <span class="n">nimages</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pclip</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="n">pclip</span> <span class="o">*=</span> <span class="n">ii</span>
            <span class="k">if</span> <span class="n">pclip</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">pclip</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">ii</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">pclip</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pclip</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">pclip</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nlow</span> <span class="o">&gt;=</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="n">nlow</span> <span class="o">/=</span> <span class="n">nimages</span>
            <span class="k">if</span> <span class="n">nhigh</span> <span class="o">&gt;=</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="n">nhigh</span> <span class="o">/=</span> <span class="n">nimages</span>

            <span class="n">ii</span> <span class="o">=</span> <span class="n">nlow</span> <span class="o">*</span> <span class="n">nimages</span>
            <span class="n">jj</span> <span class="o">=</span> <span class="n">nhigh</span> <span class="o">*</span> <span class="n">nimages</span>
            <span class="k">if</span> <span class="n">ii</span> <span class="o">+</span> <span class="n">jj</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">reject</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
            <span class="k">elif</span> <span class="n">ii</span> <span class="o">+</span> <span class="n">jj</span> <span class="o">&gt;=</span> <span class="n">nimages</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bad minmax rejection parameters&quot;</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">imin</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Map the input image(s).</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">iimages</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">image_open</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
            <span class="n">imin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Map the output image and set dimensions and offsets.</span>
        <span class="n">file_new_copy</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">imin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;NEW_COPY&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">instrument</span><span class="o">=</span><span class="n">instrument</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image_open</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;update&#39;</span><span class="p">))</span>

        <span class="c1"># start of ic_setout</span>
        <span class="n">aligned</span><span class="p">,</span> <span class="n">offarr</span> <span class="o">=</span> <span class="n">ic_setout</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">nimages</span><span class="p">,</span> <span class="n">project</span><span class="p">,</span> <span class="n">offsets</span><span class="p">)</span>

        <span class="c1"># Determine the highest precedence datatype and set output datatype.</span>
        <span class="n">intype</span> <span class="o">=</span> <span class="n">imin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">imin</span><span class="p">:</span>
            <span class="n">intype</span> <span class="o">=</span> <span class="n">type_max</span><span class="p">(</span><span class="n">intype</span><span class="p">,</span> <span class="n">im</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">outtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outtype</span> <span class="o">=</span> <span class="n">intype</span>
        <span class="c1"># make sure the output type will work given the input</span>
        <span class="n">outtype</span> <span class="o">=</span> <span class="n">type_max</span><span class="p">(</span><span class="n">intype</span><span class="p">,</span> <span class="n">outtype</span><span class="p">)</span>

        <span class="c1"># Open pixel list file if given.</span>
        <span class="k">if</span> <span class="n">plfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># XXX: this won&#39;t work if we&#39;re introducing &#39;sections&#39; of files too</span>
            <span class="c1"># need to have a &#39;return the file without the sections&#39; function</span>
            <span class="c1"># e.g. imgimage in IRAF</span>

            <span class="c1"># make sure it is a .pl file</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">plfile</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># remove the suffix if it has one</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tail</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">tail</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tail</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">tail</span> <span class="o">+=</span> <span class="s1">&#39;.pl&#39;</span>
            <span class="n">plfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">tail</span><span class="p">)</span>
            <span class="n">file_new_copy</span><span class="p">(</span><span class="n">plfile</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;NEW_COPY&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">instrument</span><span class="o">=</span><span class="n">instrument</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image_open</span><span class="p">(</span><span class="n">plfile</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;update&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">sigmatype</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Open the sigma image if given.</span>
        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">file_new_copy</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;NEW_COPY&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">instrument</span><span class="o">=</span><span class="n">instrument</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image_open</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;update&#39;</span><span class="p">))</span>
            <span class="c1"># has to be a float</span>
            <span class="n">sigmatype</span> <span class="o">=</span> <span class="n">type_max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">outtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># XXX: this currently is useless except to make sure masktype == &#39;none&#39;</span>
        <span class="c1"># Open masks.</span>
        <span class="n">masktype</span> <span class="o">=</span> <span class="n">ic_mopen</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">nimages</span><span class="p">,</span> <span class="n">masktype</span><span class="p">,</span> <span class="n">maskvalue</span><span class="p">,</span> <span class="n">instrument</span><span class="p">)</span>

        <span class="c1"># Open the log file.</span>
        <span class="n">logfd</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">logfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logfd</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">logfile</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>

        <span class="c1"># Memi[in], out, Memi[offsets], nimages</span>
        <span class="c1"># icombiner(imin, out, offsets, nimages)</span>
        <span class="c1"># this is where the icombiner function starts</span>

        <span class="c1"># icombiner seems to just be a bunch of memory handling to see if the</span>
        <span class="c1"># computer will run out of memory. We&#39;re skipping this and assuming</span>
        <span class="c1"># memory management will be taken care of behind the scenes. Move</span>
        <span class="c1"># to ic_combiner.</span>

        <span class="c1"># beginning of ic_scale</span>
        <span class="c1"># call ic_scale (in, out, offsets, scales, zeros, wts, nimages)</span>

        <span class="c1"># Set the defaults.</span>
        <span class="n">ncombine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">exptime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>
        <span class="n">medians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>
        <span class="n">modes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>
        <span class="n">scales</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>
        <span class="n">wts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>

        <span class="c1"># Get the number of images previously combined and the exposure times.</span>
        <span class="c1"># The default combine number is 1 and the default exposure is 0.</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">imin</span><span class="p">):</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;ncombine&#39;</span><span class="p">)</span>
            <span class="n">et</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;exptime&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nc</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">et</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">et</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">ncombine</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">nc</span>
            <span class="n">exptime</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">et</span>
            <span class="c1"># all the same image, so repeat these values</span>
            <span class="k">if</span> <span class="n">project</span><span class="p">:</span>
                <span class="n">ncombine</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">nc</span>
                <span class="n">exptime</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">et</span>
                <span class="k">break</span>

        <span class="c1"># Set scaling factors.</span>
        <span class="c1"># all can also be &#39;@file&#39; or &#39;!keyword&#39; which turns into</span>
        <span class="c1"># type == &#39;file&#39; or &#39;keyword&#39;</span>
        <span class="n">stypes</span> <span class="o">=</span> <span class="s2">&quot;none|mode|median|mean|exposure&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span>
        <span class="n">ztypes</span> <span class="o">=</span> <span class="s2">&quot;none|mode|median|mean&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span>
        <span class="n">wtypes</span> <span class="o">=</span> <span class="s2">&quot;none|mode|median|mean|exposure&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span>

        <span class="n">stype</span> <span class="o">=</span> <span class="n">ic_gscale</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">stypes</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">exptime</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">nimages</span><span class="p">,</span>
                          <span class="n">instrument</span><span class="p">,</span> <span class="n">project</span><span class="p">)</span>
        <span class="n">ztype</span> <span class="o">=</span> <span class="n">ic_gscale</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">ztypes</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">exptime</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">nimages</span><span class="p">,</span>
                          <span class="n">instrument</span><span class="p">,</span> <span class="n">project</span><span class="p">)</span>
        <span class="n">wtype</span> <span class="o">=</span> <span class="n">ic_gscale</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">wtypes</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">exptime</span><span class="p">,</span> <span class="n">wts</span><span class="p">,</span> <span class="n">nimages</span><span class="p">,</span>
                          <span class="n">instrument</span><span class="p">,</span> <span class="n">project</span><span class="p">)</span>

        <span class="c1"># Get image statistics only if needed.</span>
        <span class="n">domode</span> <span class="o">=</span> <span class="s1">&#39;mode&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">stype</span><span class="p">,</span> <span class="n">ztype</span><span class="p">,</span> <span class="n">wtype</span><span class="p">]</span>
        <span class="n">domedian</span> <span class="o">=</span> <span class="s1">&#39;median&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">stype</span><span class="p">,</span> <span class="n">ztype</span><span class="p">,</span> <span class="n">wtype</span><span class="p">]</span>
        <span class="n">domean</span> <span class="o">=</span> <span class="s1">&#39;mean&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">stype</span><span class="p">,</span> <span class="n">ztype</span><span class="p">,</span> <span class="n">wtype</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">domode</span> <span class="ow">or</span> <span class="n">domedian</span> <span class="ow">or</span> <span class="n">domean</span><span class="p">:</span>
            <span class="c1"># statsec options: &quot;|input|output|overlap|&quot;</span>
            <span class="k">if</span> <span class="n">statsec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">statsec</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">statsec</span> <span class="o">=</span> <span class="n">statsec</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

            <span class="n">oimref</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">section</span> <span class="o">=</span> <span class="n">statsec</span>
            <span class="k">if</span> <span class="n">statsec</span> <span class="o">==</span> <span class="s1">&#39;input&#39;</span><span class="p">:</span>
                <span class="n">section</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">elif</span> <span class="n">statsec</span> <span class="o">==</span> <span class="s1">&#39;output&#39;</span><span class="p">:</span>
                <span class="n">section</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="n">oimref</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">statsec</span> <span class="o">==</span> <span class="s1">&#39;overlap&#39;</span><span class="p">:</span>
                <span class="n">section</span> <span class="o">=</span> <span class="s1">&#39;[&#39;</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                    <span class="n">kk</span> <span class="o">=</span> <span class="n">offarr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span>
                    <span class="n">ll</span> <span class="o">=</span> <span class="n">offarr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">+</span> <span class="n">imin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nimages</span><span class="p">):</span>
                        <span class="n">kk</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">kk</span><span class="p">,</span> <span class="n">offarr</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">ii</span><span class="p">])</span>
                        <span class="n">ll</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ll</span><span class="p">,</span>
                                 <span class="n">offarr</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">+</span> <span class="n">imin</span><span class="p">[</span><span class="n">jj</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
                    <span class="n">section</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{kk:d}</span><span class="s1">:</span><span class="si">{ll:d}</span><span class="s1">,&#39;</span>
                <span class="n">section</span> <span class="o">=</span> <span class="n">section</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">section</span> <span class="o">+=</span> <span class="s1">&#39;]&#39;</span>
                <span class="n">oimref</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nimages</span><span class="p">):</span>
                <span class="n">mn</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">ic_stat</span><span class="p">(</span><span class="n">imin</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">oimref</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">offarr</span><span class="p">,</span>
                                       <span class="n">project</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">masktype</span><span class="p">,</span> <span class="n">dothresh</span><span class="p">,</span>
                                       <span class="n">lthreshold</span><span class="p">,</span> <span class="n">hthreshold</span><span class="p">,</span> <span class="n">domode</span><span class="o">=</span><span class="n">domode</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">domode</span><span class="p">:</span>
                    <span class="n">modes</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode</span>
                <span class="n">medians</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">md</span>
                <span class="n">means</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">mn</span>

                <span class="n">dc</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mn</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span> <span class="n">md</span><span class="p">,</span> <span class="s1">&#39;mode&#39;</span><span class="p">:</span> <span class="n">mode</span><span class="p">}</span>
                <span class="k">if</span> <span class="n">stype</span> <span class="ow">in</span> <span class="n">dc</span><span class="p">:</span>
                    <span class="n">scales</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">dc</span><span class="p">[</span><span class="n">stype</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ztype</span> <span class="ow">in</span> <span class="n">dc</span><span class="p">:</span>
                    <span class="n">zeros</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">dc</span><span class="p">[</span><span class="n">ztype</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">wtype</span> <span class="ow">in</span> <span class="n">dc</span><span class="p">:</span>
                    <span class="n">wts</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">dc</span><span class="p">[</span><span class="n">wtype</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">scales</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: Negative scale factors -- ignoring scaling.&quot;</span><span class="p">)</span>
            <span class="n">scales</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>

        <span class="n">snorm</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">stype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;keyword&#39;</span><span class="p">]:</span>
            <span class="n">snorm</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">znorm</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">ztype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;keyword&#39;</span><span class="p">]:</span>
            <span class="n">znorm</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">wflag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">wtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;keyword&#39;</span><span class="p">]:</span>
            <span class="n">wflag</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">snorm</span><span class="p">:</span>
            <span class="n">scales</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">scales</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scales</span> <span class="o">/=</span> <span class="n">scales</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="n">zeros</span> <span class="o">/=</span> <span class="n">scales</span>
        <span class="n">zmean</span> <span class="o">=</span> <span class="n">zeros</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="n">bad</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">wtype</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">wts</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">em</span> <span class="o">=</span> <span class="s2">&quot;WARNING: Negative weights&quot;</span>
                <span class="n">em</span> <span class="o">+=</span> <span class="s2">&quot; -- using only NCOMBINE weights.&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">em</span><span class="p">)</span>
                <span class="n">wts</span> <span class="o">=</span> <span class="n">ncombine</span> <span class="o">*</span> <span class="mi">1</span>
                <span class="n">bad</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">zeros</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">em</span> <span class="o">=</span> <span class="s2">&quot;WARNING: Negative zero offsets&quot;</span>
                <span class="n">em</span> <span class="o">+=</span> <span class="s2">&quot; -- ignoring zero weight adjustments.&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">em</span><span class="p">)</span>
                <span class="n">wts</span> <span class="o">=</span> <span class="n">ncombine</span> <span class="o">*</span> <span class="n">wts</span>
                <span class="n">bad</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">bad</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ztype</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span> <span class="ow">or</span> <span class="n">znorm</span> <span class="ow">or</span> <span class="n">wflag</span><span class="p">:</span>
                    <span class="n">wts</span> <span class="o">=</span> <span class="n">ncombine</span> <span class="o">*</span> <span class="n">wts</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">wts</span> <span class="o">=</span> <span class="n">ncombine</span> <span class="o">*</span> <span class="n">wts</span> <span class="o">*</span> <span class="n">zmean</span> <span class="o">/</span> <span class="n">zeros</span>

        <span class="k">if</span> <span class="n">znorm</span><span class="p">:</span>
            <span class="n">zeros</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zeros</span> <span class="o">-=</span> <span class="n">zmean</span>
            <span class="c1"># Because of finite arithmetic it is possible for the zero offsets</span>
            <span class="c1"># to be nonzero even when they are all equal.  Just for the sake of</span>
            <span class="c1"># a nice log set the zero offsets in this case.</span>
            <span class="n">allclose</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">zeros</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="n">zeros</span><span class="p">[</span><span class="n">ii</span><span class="p">]],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]):</span>
                    <span class="n">allclose</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">allclose</span><span class="p">:</span>
                <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>

        <span class="c1"># normalize the weights to sum to 1</span>
        <span class="n">wts</span> <span class="o">/=</span> <span class="n">wts</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># Set flags for scaling, zero offsets, sigma scaling, weights.</span>
        <span class="c1"># Sigma scaling may be suppressed if the scales or zeros are</span>
        <span class="c1"># different by a specified tolerance.</span>
        <span class="n">doscale</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">dozero</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">doscale1</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">dowts</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nimages</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">snorm</span> <span class="ow">or</span> <span class="n">scales</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="n">scales</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">doscale</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">znorm</span> <span class="ow">or</span> <span class="n">zeros</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="n">zeros</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">dozero</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">wts</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="n">wts</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">dowts</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">doscale</span> <span class="ow">and</span> <span class="n">sigscale</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">scales</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigscale</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">doscale1</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">doscale1</span> <span class="ow">and</span> <span class="n">zmean</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zeros</span> <span class="o">/</span> <span class="n">zmean</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigscale</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">doscale1</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Set the output header parameters.</span>
        <span class="n">nout</span> <span class="o">=</span> <span class="n">ncombine</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">set_header_value</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;ncombine&#39;</span><span class="p">,</span> <span class="n">nout</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="p">(</span><span class="n">wts</span> <span class="o">*</span> <span class="n">exptime</span> <span class="o">/</span> <span class="n">scales</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">darktime</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nimages</span><span class="p">):</span>
            <span class="n">dark</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">imin</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;darktime&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dark</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">darktime</span> <span class="o">+=</span> <span class="n">wts</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="n">dark</span> <span class="o">/</span> <span class="n">scales</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">darktime</span> <span class="o">+=</span> <span class="n">wts</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="n">exptime</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">/</span> <span class="n">scales</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">imin</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;ccdmean&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mean</span> <span class="o">+=</span> <span class="n">wts</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="n">mode</span> <span class="o">/</span> <span class="n">scales</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

        <span class="n">set_header_value</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;exptime&#39;</span><span class="p">,</span> <span class="n">exposure</span><span class="p">)</span>
        <span class="n">set_header_value</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;darktime&#39;</span><span class="p">,</span> <span class="n">darktime</span><span class="p">)</span>
        <span class="n">exists</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;ccdmean&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exists</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">set_header_value</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;ccdmean&#39;</span><span class="p">,</span> <span class="n">mean</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">oname</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="p">()</span>
            <span class="n">set_header_value</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;BPM&#39;</span><span class="p">,</span> <span class="n">oname</span><span class="p">)</span>

        <span class="c1"># Start the log here since much of the info is only available here.</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">logfd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">datetime</span>

            <span class="n">stack</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">project</span><span class="p">:</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">imin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;stck0001&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">stack</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Time stamp the log and print parameter information.</span>
            <span class="n">logtxt</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>
            <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{now}</span><span class="s1"> : IMCOMBINE</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;  combine = </span><span class="si">{method}</span><span class="s1">, &#39;</span>
            <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;scale = </span><span class="si">{scale}</span><span class="s1">, zero = </span><span class="si">{zero}</span><span class="s1">, &#39;</span>
            <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;weight = </span><span class="si">{weight}</span><span class="se">\n</span><span class="s1">&#39;</span>

            <span class="c1"># REJECT &quot;|none|ccdclip|crreject|minmax|pclip|sigclip|avsigclip|&quot;</span>
            <span class="k">if</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
                <span class="n">ostr</span> <span class="o">=</span> <span class="s1">&#39;  reject = minmax, nlow = </span><span class="si">{0:d}</span><span class="s1">, nhigh = </span><span class="si">{1:d}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">slow</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nlow</span> <span class="o">*</span> <span class="n">nimages</span><span class="p">))</span>
                <span class="n">shigh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nhigh</span> <span class="o">*</span> <span class="n">nimages</span><span class="p">))</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">ostr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">slow</span><span class="p">,</span> <span class="n">shigh</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;ccdclip&#39;</span><span class="p">:</span>
                <span class="n">ostr</span> <span class="o">=</span> <span class="s1">&#39;  reject = ccdclip, mclip = </span><span class="si">{0}</span><span class="s1">, nkeep = </span><span class="si">{1:d}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">ostr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mclip</span><span class="p">,</span> <span class="n">nkeep</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rdnoise</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ostr</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  rdnoise = </span><span class="si">{rdnoise}</span><span class="s1">&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ostr</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  rdnoise = </span><span class="si">{rdnoise:g}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gain</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;, gain = </span><span class="si">{gain}</span><span class="s1">, &#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;, gain = </span><span class="si">{gain:g}</span><span class="s1">, &#39;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snoise</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;snoise = </span><span class="si">{snoise}</span><span class="s1">, &#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;snoise = </span><span class="si">{snoise:g}</span><span class="s1">, &#39;</span>
                <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;lsigma = </span><span class="si">{lsigma:g}</span><span class="s1">, hsigma = </span><span class="si">{hsigma:g}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">ostr</span>
            <span class="k">elif</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;crreject&#39;</span><span class="p">:</span>
                <span class="n">ostr</span> <span class="o">=</span> <span class="s1">&#39;  reject = crreject, mclip = </span><span class="si">{0}</span><span class="s1">, nkeep = </span><span class="si">{1:d}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">ostr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mclip</span><span class="p">,</span> <span class="n">nkeep</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rdnoise</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ostr</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  rdnoise = </span><span class="si">{rdnoise}</span><span class="s1">&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ostr</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  rdnoise = </span><span class="si">{rdnoise:g}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gain</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;, gain = </span><span class="si">{gain}</span><span class="s1">, &#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;, gain = </span><span class="si">{gain:g}</span><span class="s1">, &#39;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snoise</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;snoise = </span><span class="si">{snoise}</span><span class="s1">, &#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;snoise = </span><span class="si">{snoise:g}</span><span class="s1">, &#39;</span>
                <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;hsigma = </span><span class="si">{hsigma:g}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">ostr</span>
            <span class="k">elif</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;pclip&#39;</span><span class="p">:</span>
                <span class="n">ostr</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  reject = pclip, nkeep = </span><span class="si">{nkeep:d}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">ostr</span>
                <span class="n">ostr</span> <span class="o">=</span> <span class="s1">&#39;  pclip = </span><span class="si">{0:g}</span><span class="s1">, lsigma = </span><span class="si">{1:g}</span><span class="s1">, hsigma = </span><span class="si">{2:g}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">ostr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pclip</span><span class="p">,</span> <span class="n">lsigma</span><span class="p">,</span> <span class="n">hsigma</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;sigclip&#39;</span><span class="p">:</span>
                <span class="n">ostr</span> <span class="o">=</span> <span class="s1">&#39;  reject = sigclip, mclip = </span><span class="si">{0}</span><span class="s1">, nkeep = </span><span class="si">{1:d}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">ostr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mclip</span><span class="p">,</span> <span class="n">nkeep</span><span class="p">)</span>
                <span class="n">ostr</span> <span class="o">=</span> <span class="s1">&#39;  lsigma = </span><span class="si">{0:g}</span><span class="s1">, hsigma = </span><span class="si">{1:g}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">ostr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lsigma</span><span class="p">,</span> <span class="n">hsigma</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;avsigclip&#39;</span><span class="p">:</span>
                <span class="n">ostr</span> <span class="o">=</span> <span class="s1">&#39;  reject = avsigclip, mclip = </span><span class="si">{0}</span><span class="s1">, nkeep = </span><span class="si">{1:d}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">ostr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mclip</span><span class="p">,</span> <span class="n">nkeep</span><span class="p">)</span>
                <span class="n">ostr</span> <span class="o">=</span> <span class="s1">&#39;  lsigma = </span><span class="si">{0:g}</span><span class="s1">, hsigma = </span><span class="si">{1:g}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">ostr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lsigma</span><span class="p">,</span> <span class="n">hsigma</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">reject</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span> <span class="ow">and</span> <span class="n">grow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;  grow = </span><span class="si">{grow:d}</span><span class="se">\n</span><span class="s1">&#39;</span>

            <span class="k">if</span> <span class="n">dothresh</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lthreshold</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="ow">and</span> <span class="n">hthreshold</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                    <span class="n">ostr</span> <span class="o">=</span> <span class="s1">&#39;  lthreshold = </span><span class="si">{0:g}</span><span class="s1">, hthreshold = </span><span class="si">{1:g}</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="n">ostr</span> <span class="o">=</span> <span class="n">ostr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lthreshold</span><span class="p">,</span> <span class="n">hthreshold</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">lthreshold</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                    <span class="n">ostr</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  lthreshold = </span><span class="si">{lthreshold:g}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ostr</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  hthreshold = </span><span class="si">{hthreshold:g}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">ostr</span>

            <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;  blank = </span><span class="si">{blank:g}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">statsec</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;  statsec = </span><span class="si">{statsec}</span><span class="se">\n</span><span class="s1">&#39;</span>

            <span class="k">if</span> <span class="n">masktype</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mask types not yet supported&#39;</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">dop</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ncombine&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;exptime&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;mode&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="s1">&#39;median&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;rdn&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="s1">&#39;gain&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;sn&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nimages</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ncombine</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ncombine</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;ncombine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">exptime</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="n">exptime</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;exptime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">modes</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="n">modes</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">medians</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="n">medians</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;median&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">means</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="n">means</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">masktype</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mask types not yet supported&#39;</span><span class="p">)</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;ccdclip&#39;</span> <span class="ow">or</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;crreject&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rdnoise</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;rdn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gain</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;gain&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snoise</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">hdr</span> <span class="o">=</span> <span class="s1">&#39;  </span><span class="si">{0:20s}</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Images&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;ncombine&#39;</span><span class="p">]:</span>
                <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{0:6s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;NComb&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;exptime&#39;</span><span class="p">]:</span>
                <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{0:6s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;ExpT&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]:</span>
                <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{0:7s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Mode&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;median&#39;</span><span class="p">]:</span>
                <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{0:7s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Median&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]:</span>
                <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{0:7s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Mean&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;rdn&#39;</span><span class="p">]:</span>
                <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{0:7s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;RdNoise&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;gain&#39;</span><span class="p">]:</span>
                <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{0:6s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Gain&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">]:</span>
                <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{0:6s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;SNoise&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">doscale</span><span class="p">:</span>
                <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{0:6s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Scale&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dozero</span><span class="p">:</span>
                <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{0:7s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Zero&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dowts</span><span class="p">:</span>
                <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{0:6s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Weight&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">aligned</span><span class="p">:</span>
                <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{0:9s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Offsets&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]:</span>
                <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{0:s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Maskfile&#39;</span><span class="p">)</span>
            <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">hdr</span>

            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nimages</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
                    <span class="n">stc</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;stck</span><span class="si">{ii:04d}</span><span class="s1">&#39;</span>
                    <span class="n">vl</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">imin</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">stc</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">vl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">ostr</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  </span><span class="si">{vl:21s}</span><span class="s1">&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ostr</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  {imin[ii].filename():16s}[</span><span class="si">{ii:03d}</span><span class="s1">]&#39;</span>
                <span class="k">elif</span> <span class="n">project</span><span class="p">:</span>
                    <span class="n">ostr</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  {imin[ii].filename():16s}[</span><span class="si">{ii:03d}</span><span class="s1">]&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ostr</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;  {imin[ii].filename():21s}&#39;</span>
                <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;ncombine&#39;</span><span class="p">]:</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{ncombine[ii]:6d}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;exptime&#39;</span><span class="p">]:</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{exptime[ii]:6.1f}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]:</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{modes[ii]:7.5g}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;median&#39;</span><span class="p">]:</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{medians[ii]:7.5g}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]:</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{means[ii]:7.5g}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;rdn&#39;</span><span class="p">]:</span>
                    <span class="n">rval</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">imin</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">rdnoise</span><span class="p">)</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{rval:7g}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;gain&#39;</span><span class="p">]:</span>
                    <span class="n">rval</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">imin</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">gain</span><span class="p">)</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{rval:6g}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;sn&#39;</span><span class="p">]:</span>
                    <span class="n">rval</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">imin</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">snoise</span><span class="p">)</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{rval:6g}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="n">doscale</span><span class="p">:</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39; {1./scales[ii]:6.3f}&#39;</span>
                <span class="k">if</span> <span class="n">dozero</span><span class="p">:</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39; {-zeros[ii]:7.5g}&#39;</span>
                <span class="k">if</span> <span class="n">dowts</span><span class="p">:</span>
                    <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{wts[ii]:6.3f}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">aligned</span><span class="p">:</span>
                    <span class="n">nd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="c1"># number of dimensions in out array</span>
                    <span class="n">nd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nd</span><span class="p">[</span><span class="n">nd</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">nd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{offarr[ii, 0]:9d}</span><span class="s1">&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">use</span> <span class="o">=</span> <span class="n">offarr</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span>
                        <span class="n">strs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s1">&#39; </span><span class="si">{ixx:4d}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">ixx</span> <span class="ow">in</span> <span class="n">use</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">istr</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
                            <span class="n">ostr</span> <span class="o">+=</span> <span class="n">istr</span>
                <span class="k">if</span> <span class="n">dop</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mask types not yet supported&#39;</span><span class="p">)</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ostr</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">ostr</span>

            <span class="c1"># Log information about the output images.</span>
            <span class="n">ostr</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">  Output image = </span><span class="si">{0}</span><span class="s1">, ncombine = </span><span class="si">{1:d}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">ostr</span> <span class="o">=</span> <span class="n">ostr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="p">(),</span> <span class="n">nout</span><span class="p">)</span>
            <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">ostr</span>

            <span class="k">if</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;  Pixel list image = {out[1].filename()}</span><span class="se">\n</span><span class="s1">&#39;</span>

            <span class="k">if</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logtxt</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;  Sigma image = {out[2].filename()}</span><span class="se">\n</span><span class="s1">&#39;</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">logtxt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">logfd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logfd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">logtxt</span><span class="p">)</span>

        <span class="n">doscale</span> <span class="o">=</span> <span class="p">(</span><span class="n">doscale</span> <span class="ow">or</span> <span class="n">dozero</span><span class="p">)</span>
        <span class="c1"># end of the icscale function</span>
        <span class="n">keepids</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span> <span class="ow">and</span> <span class="n">dowts</span><span class="p">:</span>
            <span class="n">keepids</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
            <span class="n">dowts</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">docombine</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Set rejection algorithm specific parameters</span>
        <span class="k">if</span> <span class="n">reject</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ccdclip&#39;</span><span class="p">,</span> <span class="s1">&#39;crreject&#39;</span><span class="p">]:</span>
            <span class="c1"># the column order is readnoise, gain, snoise</span>
            <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nimages</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rdnoise</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nimages</span><span class="p">):</span>
                    <span class="n">nm</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">imin</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">rdnoise</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdnoise</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gain</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nimages</span><span class="p">):</span>
                    <span class="n">nm</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">imin</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">gain</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nm</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">gain</span>
            <span class="n">max_real</span> <span class="o">=</span> <span class="mf">0.99e37</span>
            <span class="n">small</span> <span class="o">=</span> <span class="mf">1e4</span> <span class="o">/</span> <span class="n">max_real</span>
            <span class="c1"># adjust the readnoise values? don&#39;t let it be actually 0?</span>
            <span class="n">rdsq</span> <span class="o">=</span> <span class="p">(</span><span class="n">nm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">nm</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">nm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rdsq</span> <span class="o">&gt;</span> <span class="n">small</span><span class="p">,</span> <span class="n">rdsq</span><span class="p">,</span> <span class="p">[</span><span class="n">small</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snoise</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nimages</span><span class="p">):</span>
                    <span class="n">nm</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">imin</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">snoise</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nm</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">snoise</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">keepids</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">doscale1</span> <span class="ow">or</span> <span class="n">grow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">keepids</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># see if every row is the same as the first row</span>
                    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nimages</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">nm</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">!=</span> <span class="n">nm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="n">keepids</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
            <span class="k">if</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;crreject&#39;</span><span class="p">:</span>
                <span class="n">lsigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">elif</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
            <span class="n">mclip</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">grow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">keepids</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;pclip&#39;</span><span class="p">:</span>
            <span class="n">mclip</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">grow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">keepids</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">reject</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;sigclip&#39;</span><span class="p">,</span> <span class="s1">&#39;avsigclip&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">doscale1</span> <span class="ow">or</span> <span class="n">grow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">keepids</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># case &#39;none&#39;</span>
            <span class="n">mclip</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">grow</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># start of ic_gdatar</span>
        <span class="n">oshp</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">oshp</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nimages</span><span class="p">,)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">oshp</span><span class="p">)</span>
        <span class="c1"># set bad values</span>
        <span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># easy case, no offsets to deal with</span>
        <span class="k">if</span> <span class="n">aligned</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nimages</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">imin</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;need to handle offsets in combine&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># remove the data points with bad mask values (set to nan)</span>
        <span class="k">if</span> <span class="n">masktype</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;need to implement mask types&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Apply threshold if needed</span>
        <span class="k">if</span> <span class="n">dothresh</span><span class="p">:</span>
            <span class="n">nothr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">lthreshold</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">hthreshold</span><span class="p">))</span>
            <span class="n">data</span><span class="p">[</span><span class="n">nothr</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Apply scaling (avoiding masked pixels which might overflow?)</span>
        <span class="k">if</span> <span class="n">doscale</span><span class="p">:</span>
            <span class="c1"># XXX: this seems to be the wrong order. bug in ic_gdatar?</span>
            <span class="n">data</span> <span class="o">/=</span> <span class="n">scales</span>
            <span class="n">data</span> <span class="o">-=</span> <span class="n">zeros</span>

        <span class="c1"># end of ic_gdatar</span>
        <span class="k">if</span> <span class="n">reject</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ccdclip&#39;</span><span class="p">,</span> <span class="s1">&#39;crreject&#39;</span><span class="p">,</span> <span class="s1">&#39;sigclip&#39;</span><span class="p">,</span> <span class="s1">&#39;avsigclip&#39;</span><span class="p">]:</span>
            <span class="n">minclip</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">reject</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;sigclip&#39;</span><span class="p">,</span> <span class="s1">&#39;avsigclip&#39;</span><span class="p">]:</span>
                <span class="n">minclip</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="c1"># number of good points to use</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nkeep</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">minkeep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">npts</span> <span class="o">+</span> <span class="n">nkeep</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">npts</span> <span class="o">+</span> <span class="n">nkeep</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">minkeep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">npts</span> <span class="o">&lt;</span> <span class="n">nkeep</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="p">[</span><span class="n">nkeep</span><span class="p">])</span>

            <span class="n">finsig</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">if</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;avsigclip&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mclip</span><span class="p">:</span>
                    <span class="c1"># XXX: catch RuntimeWarning for all nan rows</span>
                    <span class="n">meds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">totals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># if there are 3+ data points, use the min/max removed avg</span>
                    <span class="n">adjnpts</span> <span class="o">=</span> <span class="n">npts</span> <span class="o">*</span> <span class="mi">1</span>
                    <span class="c1"># this adjustment method will fail if there are infinities</span>
                    <span class="n">totals</span><span class="p">[</span><span class="n">adjnpts</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">adjnpts</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">],</span>
                                                      <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">totals</span><span class="p">[</span><span class="n">adjnpts</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">adjnpts</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">],</span>
                                                      <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">adjnpts</span><span class="p">[</span><span class="n">adjnpts</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span>
                    <span class="n">meds</span> <span class="o">=</span> <span class="n">totals</span> <span class="o">/</span> <span class="n">adjnpts</span>
                <span class="c1"># Compute the poisson scaled average sigma about the median.</span>
                <span class="c1"># There must be at least three pixels at each point to define</span>
                <span class="c1"># the mean sigma.  Corrections for differences in the image</span>
                <span class="c1"># scale factors are selected by the doscale1 flag.</span>
                <span class="k">if</span> <span class="n">doscale1</span><span class="p">:</span>
                    <span class="n">rr</span> <span class="o">=</span> <span class="p">(</span><span class="n">meds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">zeros</span><span class="p">)</span> <span class="o">/</span> <span class="n">scales</span>
                    <span class="n">rr</span><span class="p">[</span><span class="n">rr</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="n">ss</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">meds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">**</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">rr</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">meds</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">meds</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.</span><span class="p">])</span>
                    <span class="n">ss</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span> <span class="o">-</span> <span class="n">meds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">**</span><span class="mf">2.</span> <span class="o">/</span>
                          <span class="n">rr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
                <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="n">npts</span> <span class="o">&gt;=</span> <span class="mi">3</span>
                <span class="c1"># XXX: in IRAF this sum is only done along each &quot;row&quot;, or along</span>
                <span class="c1"># the first dimension since that&#39;s what ic_gdatar and impnlr</span>
                <span class="c1"># deal with</span>
                <span class="c1"># Here is the final sigma.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">finsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ss</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># don&#39;t do any clipping, so effectively ignore everything</span>
                    <span class="n">finsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="n">finished</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">finished</span><span class="p">[(</span><span class="n">npts</span> <span class="o">&lt;</span> <span class="n">minclip</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">npts</span> <span class="o">&lt;=</span> <span class="n">minkeep</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">finished</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">mclip</span><span class="p">:</span>
                    <span class="c1"># XXX: catch RuntimeWarning for all nan rows</span>
                    <span class="n">meds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">totals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># if there are 3+ data points, use the min/max removed avg</span>
                    <span class="n">adjnpts</span> <span class="o">=</span> <span class="n">npts</span> <span class="o">*</span> <span class="mi">1</span>
                    <span class="c1"># this adjustment method will fail if there are infinities</span>
                    <span class="n">totals</span><span class="p">[</span><span class="n">adjnpts</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">adjnpts</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">],</span>
                                                      <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">totals</span><span class="p">[</span><span class="n">adjnpts</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">adjnpts</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">],</span>
                                                      <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">adjnpts</span><span class="p">[</span><span class="n">adjnpts</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span>
                    <span class="n">meds</span> <span class="o">=</span> <span class="n">totals</span> <span class="o">/</span> <span class="n">adjnpts</span>

                <span class="k">if</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;sigclip&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">doscale1</span><span class="p">:</span>
                        <span class="c1"># Compute the sigma with scaling correction.</span>
                        <span class="n">rr</span> <span class="o">=</span> <span class="p">(</span><span class="n">meds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">zeros</span><span class="p">)</span> <span class="o">/</span> <span class="n">scales</span>
                        <span class="n">rr</span><span class="p">[</span><span class="n">rr</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                        <span class="n">rr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rr</span><span class="p">)</span>
                        <span class="n">ss</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span> <span class="o">-</span> <span class="n">meds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">/</span> <span class="n">rr</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.</span>
                        <span class="c1"># this is just to compute the standard deviation in</span>
                        <span class="c1"># each pixel (with 1 degree of freedom)</span>
                        <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">npts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="c1"># ignore points where ss == 0 to avoid divide by 0</span>
                        <span class="c1"># and because we can&#39;t cut them out anyway</span>
                        <span class="n">ss</span><span class="p">[</span><span class="n">ss</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                        <span class="n">negresids</span> <span class="o">=</span> <span class="p">((</span><span class="n">meds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">)</span> <span class="o">/</span>
                                     <span class="p">(</span><span class="n">ss</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">rr</span><span class="p">))</span>
                        <span class="n">bad</span> <span class="o">=</span> <span class="p">((</span><span class="n">negresids</span> <span class="o">&gt;=</span> <span class="n">lsigma</span><span class="p">)</span> <span class="o">|</span>
                               <span class="p">(</span><span class="o">-</span><span class="mf">1.</span> <span class="o">*</span> <span class="n">negresids</span> <span class="o">&gt;=</span> <span class="n">hsigma</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Compute the sigma without scaling correction.</span>
                        <span class="n">ss</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">meds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.</span>
                        <span class="c1"># this is just to compute the standard deviation in</span>
                        <span class="c1"># each pixel (with 1 degree of freedom)</span>
                        <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">npts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="c1"># ignore points where ss == 0 to avoid divide by 0</span>
                        <span class="c1"># and because we can&#39;t cut them out anyway</span>
                        <span class="n">ss</span><span class="p">[</span><span class="n">ss</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                        <span class="n">negresids</span> <span class="o">=</span> <span class="p">((</span><span class="n">meds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">)</span> <span class="o">/</span>
                                     <span class="n">ss</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
                        <span class="n">bad</span> <span class="o">=</span> <span class="p">((</span><span class="n">negresids</span> <span class="o">&gt;=</span> <span class="n">lsigma</span><span class="p">)</span> <span class="o">|</span>
                               <span class="p">(</span><span class="o">-</span><span class="mf">1.</span> <span class="o">*</span> <span class="n">negresids</span> <span class="o">&gt;=</span> <span class="n">hsigma</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;avsigclip&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">doscale1</span><span class="p">:</span>
                        <span class="n">rr</span> <span class="o">=</span> <span class="p">(</span><span class="n">meds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">zeros</span><span class="p">)</span> <span class="o">/</span> <span class="n">scales</span>
                        <span class="n">rr</span><span class="p">[</span><span class="n">rr</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                        <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rr</span><span class="p">)</span> <span class="o">*</span> <span class="n">finsig</span>
                        <span class="n">negresids</span> <span class="o">=</span> <span class="p">(</span><span class="n">meds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">ss</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">meds</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">meds</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.</span><span class="p">])</span>
                        <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rr</span><span class="p">)</span> <span class="o">*</span> <span class="n">finsig</span>
                        <span class="n">negresids</span> <span class="o">=</span> <span class="p">((</span><span class="n">meds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">)</span> <span class="o">/</span>
                                     <span class="n">ss</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
                    <span class="n">bad</span> <span class="o">=</span> <span class="p">((</span><span class="n">negresids</span> <span class="o">&gt;</span> <span class="n">lsigma</span><span class="p">)</span> <span class="o">|</span>
                           <span class="p">(</span><span class="o">-</span><span class="mf">1.</span> <span class="o">*</span> <span class="n">negresids</span> <span class="o">&gt;</span> <span class="n">hsigma</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">doscale1</span><span class="p">:</span>
                        <span class="n">rescale</span> <span class="o">=</span> <span class="n">scales</span> <span class="o">*</span> <span class="p">(</span><span class="n">meds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">zeros</span><span class="p">)</span>
                        <span class="n">rr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rescale</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">rescale</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.</span><span class="p">])</span>
                        <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">rr</span> <span class="o">/</span> <span class="n">nm</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                     <span class="p">(</span><span class="n">rr</span> <span class="o">*</span> <span class="n">nm</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">scales</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">meds</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">meds</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.</span><span class="p">])</span>
                        <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">rr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">/</span> <span class="n">nm</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                     <span class="p">(</span><span class="n">rr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">nm</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

                    <span class="n">negresids</span> <span class="o">=</span> <span class="p">(</span><span class="n">meds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">ss</span>
                    <span class="c1"># these don&#39;t pass the cut</span>
                    <span class="n">bad</span> <span class="o">=</span> <span class="p">((</span><span class="n">negresids</span> <span class="o">&gt;=</span> <span class="n">lthreshold</span><span class="p">)</span> <span class="o">|</span>
                           <span class="p">(</span><span class="o">-</span><span class="mf">1.</span> <span class="o">*</span> <span class="n">negresids</span> <span class="o">&gt;=</span> <span class="n">hthreshold</span><span class="p">))</span>

                <span class="c1"># number that are bad in a given pixel</span>
                <span class="n">totbad</span> <span class="o">=</span> <span class="n">bad</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># the easy case of things to update</span>
                <span class="n">toup</span> <span class="o">=</span> <span class="p">(</span><span class="n">totbad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">npts</span> <span class="o">-</span> <span class="n">totbad</span> <span class="o">&gt;=</span> <span class="n">minkeep</span><span class="p">)</span>
                <span class="n">replace</span> <span class="o">=</span> <span class="n">toup</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">bad</span>
                <span class="n">data</span><span class="p">[</span><span class="n">replace</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="c1"># only remove the worst outliers in these cases.</span>
                <span class="c1"># not sure there&#39;s a pythonic way to do this, so loop it.</span>
                <span class="n">caution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">totbad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">npts</span> <span class="o">-</span> <span class="n">totbad</span> <span class="o">&lt;</span> <span class="n">minkeep</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">caution</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                    <span class="n">inds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cc</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">caution</span><span class="p">)</span>
                    <span class="c1"># get only this pixel&#39;s values in every image</span>
                    <span class="n">maxresid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">negresids</span><span class="p">[</span><span class="n">inds</span><span class="p">])</span>
                    <span class="c1"># how many pixels we&#39;re allowed to remove</span>
                    <span class="n">nrem</span> <span class="o">=</span> <span class="n">npts</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span> <span class="o">-</span> <span class="n">minkeep</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
                    <span class="k">while</span> <span class="n">nrem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># find all values equal to the current max</span>
                        <span class="n">torem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">maxresid</span><span class="p">,</span>
                                                    <span class="n">maxresid</span><span class="o">.</span><span class="n">max</span><span class="p">()))[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="c1"># only remove all equal values if doing so doesn&#39;t</span>
                        <span class="c1">#  put us below the limit</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">torem</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">nrem</span><span class="p">:</span>
                            <span class="n">data</span><span class="p">[</span><span class="n">inds</span> <span class="o">+</span> <span class="p">(</span><span class="n">torem</span><span class="p">,)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                        <span class="n">nrem</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">torem</span><span class="p">)</span>
                    <span class="c1"># mark this one as finished, even if we&#39;re keeping</span>
                    <span class="c1"># values above minkeep because there are</span>
                    <span class="c1"># multiple equal values</span>
                    <span class="n">finished</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># finished is updated where totbad == 0 or npts == minkeep</span>
                <span class="c1"># or npts &lt; minclip</span>
                <span class="n">npts</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">finished</span><span class="p">[(</span><span class="n">totbad</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">npts</span> <span class="o">==</span> <span class="n">minkeep</span><span class="p">)</span> <span class="o">|</span>
                         <span class="p">(</span><span class="n">npts</span> <span class="o">&lt;</span> <span class="n">minclip</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
            <span class="c1"># number of good points to use</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="n">npts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># number of points to reject both high and low</span>
            <span class="n">totlow</span> <span class="o">=</span> <span class="n">nlow</span> <span class="o">*</span> <span class="n">npts</span>
            <span class="n">tothigh</span> <span class="o">=</span> <span class="n">nhigh</span> <span class="o">*</span> <span class="n">npts</span>
            <span class="c1"># if we need to remove lower points</span>
            <span class="k">if</span> <span class="n">totlow</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="c1"># save the locations of bad points</span>
                <span class="n">rbad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="c1"># while finding mins, replace them with infs</span>
                <span class="c1"># necessary because rows of all nans will raise a ValueError in</span>
                <span class="c1"># nanargmin or nanargmax</span>
                <span class="n">data</span><span class="p">[</span><span class="n">rbad</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="c1"># loop through and replace as many as needed</span>
                <span class="k">while</span> <span class="n">totlow</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mf">1.</span><span class="p">:</span>
                    <span class="n">mins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># only the spots we want to remove the min points</span>
                    <span class="n">torep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">totlow</span> <span class="o">&gt;=</span> <span class="mf">1.</span><span class="p">)</span>
                    <span class="n">torep</span> <span class="o">+=</span> <span class="p">(</span><span class="n">mins</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">totlow</span> <span class="o">&gt;=</span> <span class="mf">1.</span><span class="p">)],)</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">torep</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="n">rbad</span><span class="p">[</span><span class="n">torep</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">totlow</span> <span class="o">-=</span> <span class="mf">1.</span>
                <span class="n">data</span><span class="p">[</span><span class="n">rbad</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="c1"># if we need to remove higher points</span>
            <span class="k">if</span> <span class="n">tothigh</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="c1"># save the locations of bad points</span>
                <span class="n">rbad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="c1"># while finding mins, replace them with negative infs</span>
                <span class="c1"># necessary because rows of all nans will raise a ValueError in</span>
                <span class="c1"># nanargmin or nanargmax</span>
                <span class="n">data</span><span class="p">[</span><span class="n">rbad</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="c1"># loop through and replace as many as needed</span>
                <span class="k">while</span> <span class="n">tothigh</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mf">1.</span><span class="p">:</span>
                    <span class="n">maxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># only the spots we want to remove the max points</span>
                    <span class="n">torep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tothigh</span> <span class="o">&gt;=</span> <span class="mf">1.</span><span class="p">)</span>
                    <span class="n">torep</span> <span class="o">+=</span> <span class="p">(</span><span class="n">maxs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tothigh</span> <span class="o">&gt;=</span> <span class="mf">1.</span><span class="p">)],)</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">torep</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="n">rbad</span><span class="p">[</span><span class="n">torep</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">tothigh</span> <span class="o">-=</span> <span class="mf">1.</span>
                <span class="n">data</span><span class="p">[</span><span class="n">rbad</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">elif</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;pclip&#39;</span><span class="p">:</span>
            <span class="n">minclip</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nkeep</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">minkeep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">npts</span> <span class="o">+</span> <span class="n">nkeep</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">npts</span> <span class="o">+</span> <span class="n">nkeep</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">minkeep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">npts</span> <span class="o">&lt;</span> <span class="n">nkeep</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="p">[</span><span class="n">nkeep</span><span class="p">])</span>

            <span class="c1"># Set sign of pclip parameter</span>
            <span class="k">if</span> <span class="n">pclip</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="mf">1.</span>

            <span class="n">meds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># the median value or the rightmost of the 2 median values</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">npts</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">pclip</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="c1"># whether or not we have an even number of points</span>
                <span class="n">even</span> <span class="o">=</span> <span class="p">(</span><span class="n">npts</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="c1"># set the clipping index at n2 - abs(pclip), but using the left</span>
                <span class="c1"># edge of the median if even</span>
                <span class="c1"># can&#39;t be below the first index of course</span>
                <span class="n">n3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">n2</span> <span class="o">-</span> <span class="n">even</span> <span class="o">+</span> <span class="n">pclip</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">n2</span> <span class="o">-</span> <span class="n">even</span> <span class="o">+</span> <span class="n">pclip</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># set the clipping index at n2 + pclip, but can&#39;t be</span>
                <span class="c1"># beyond the max number of images</span>
                <span class="n">n3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">npts</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">n2</span> <span class="o">+</span> <span class="n">pclip</span><span class="p">),</span> <span class="n">npts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">n2</span> <span class="o">+</span> <span class="n">pclip</span><span class="p">))</span>
            <span class="n">n3</span> <span class="o">=</span> <span class="n">n3</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

            <span class="c1"># the data needs to be sorted. NaNs are at the end, beyond npts,</span>
            <span class="c1"># so they are ignored.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Define sigma for clipping</span>
            <span class="n">oinds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">meds</span><span class="o">.</span><span class="n">shape</span><span class="p">],</span>
                                <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
            <span class="n">oinds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n3</span><span class="p">)</span>
            <span class="n">msigma</span> <span class="o">=</span> <span class="n">tt</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">oinds</span><span class="p">]</span> <span class="o">-</span> <span class="n">meds</span><span class="p">)</span>
            <span class="c1"># skip over ones where sigma is 0 or there&#39;s not enough pixels</span>
            <span class="n">msigma</span><span class="p">[(</span><span class="n">msigma</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">npts</span> <span class="o">&lt;</span> <span class="n">minclip</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="n">negresids</span> <span class="o">=</span> <span class="p">(</span><span class="n">meds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">msigma</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

            <span class="c1"># these don&#39;t pass the cut</span>
            <span class="n">bad</span> <span class="o">=</span> <span class="p">((</span><span class="n">negresids</span> <span class="o">&gt;</span> <span class="n">lsigma</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.</span> <span class="o">*</span> <span class="n">negresids</span> <span class="o">&gt;</span> <span class="n">hsigma</span><span class="p">))</span>
            <span class="c1"># number that are bad in a given pixel</span>
            <span class="n">totbad</span> <span class="o">=</span> <span class="n">bad</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># the easy case of things to update</span>
            <span class="n">toup</span> <span class="o">=</span> <span class="p">(</span><span class="n">totbad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">npts</span> <span class="o">-</span> <span class="n">totbad</span> <span class="o">&gt;=</span> <span class="n">minkeep</span><span class="p">)</span>
            <span class="n">replace</span> <span class="o">=</span> <span class="n">toup</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">bad</span>
            <span class="n">data</span><span class="p">[</span><span class="n">replace</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="c1"># only remove the worst outliers in these cases.</span>
            <span class="c1"># not sure there&#39;s a pythonic way to do this, so loop it.</span>
            <span class="n">caution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">totbad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">npts</span> <span class="o">-</span> <span class="n">totbad</span> <span class="o">&lt;</span> <span class="n">minkeep</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">caution</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="n">inds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cc</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">caution</span><span class="p">)</span>
                <span class="c1"># get only this pixel&#39;s values in every image</span>
                <span class="n">maxresid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">negresids</span><span class="p">[</span><span class="n">inds</span><span class="p">])</span>
                <span class="c1"># how many pixels we&#39;re allowed to remove</span>
                <span class="n">nrem</span> <span class="o">=</span> <span class="n">npts</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span> <span class="o">-</span> <span class="n">minkeep</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
                <span class="k">while</span> <span class="n">nrem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># find all values equal to the current max</span>
                    <span class="n">torem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">maxresid</span><span class="p">,</span>
                                                <span class="n">maxresid</span><span class="o">.</span><span class="n">max</span><span class="p">()))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># only remove all equal values if doing so doesn&#39;t</span>
                    <span class="c1">#  put us below the limit</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">torem</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">nrem</span><span class="p">:</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">inds</span> <span class="o">+</span> <span class="p">(</span><span class="n">torem</span><span class="p">,)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">nrem</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">torem</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">grow</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;grow needs to be implemented&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># grow is only 1-D in IRAF. along the first? dimension?</span>
            <span class="c1"># badpts = np.isnan(data)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span>
            <span class="c1"># same shape as data, but all ones except for the NaNs</span>
            <span class="n">fullwts</span> <span class="o">=</span> <span class="n">data</span> <span class="o">*</span> <span class="mf">0.</span> <span class="o">+</span> <span class="mf">1.</span>
            <span class="c1"># fill in the actual wts values, keeping the NaNs</span>
            <span class="n">fullwts</span> <span class="o">*=</span> <span class="n">wts</span>
            <span class="n">totsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">data</span> <span class="o">*</span> <span class="n">fullwts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">totwts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">fullwts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># compute the average</span>
            <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">totsum</span><span class="p">)</span>
            <span class="n">avg</span><span class="p">[</span><span class="n">totwts</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">totsum</span><span class="p">[</span><span class="n">totwts</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">/</span> <span class="n">totwts</span><span class="p">[</span><span class="n">totwts</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">]</span>
            <span class="c1"># fill in empty spots with the blank value</span>
            <span class="n">avg</span><span class="p">[</span><span class="n">totwts</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">blank</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># compute the median</span>
            <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># fill in empty spots with the blank value</span>
            <span class="n">avg</span><span class="p">[</span><span class="n">npts</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">blank</span>
        <span class="c1"># save the final result to the output image</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">avg</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">nbad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span> <span class="o">*</span> <span class="n">nimages</span>
            <span class="c1"># how many bad pixels there were</span>
            <span class="n">nbad</span> <span class="o">-=</span> <span class="n">npts</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">nbad</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Compute the sigma image line.</span>
            <span class="c1"># The estimated sigma includes a correction for the</span>
            <span class="c1"># finite population. Weights are used if desired.</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># same shape as data, but all ones except for the NaNs</span>
            <span class="n">fullwts</span> <span class="o">=</span> <span class="n">data</span> <span class="o">*</span> <span class="mf">0.</span> <span class="o">+</span> <span class="mf">1.</span>
            <span class="c1"># fill in the actual wts values, keeping the NaNs</span>
            <span class="n">fullwts</span> <span class="o">*=</span> <span class="n">wts</span>

            <span class="n">sigcor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">npts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">npts</span><span class="o">/</span><span class="p">(</span><span class="n">npts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">wtsum</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">avg</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fullwts</span>
            <span class="n">wtsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">wtsum</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">totwts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">fullwts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">wtsum</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">totwts</span> <span class="o">&gt;</span> <span class="mf">0.</span>
            <span class="n">sigma</span><span class="p">[</span><span class="n">totwts</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigcor</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">*</span> <span class="n">wtsum</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">/</span> <span class="n">totwts</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
            <span class="n">sigma</span><span class="p">[</span><span class="n">totwts</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">blank</span>

            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sigma</span>
            <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="c1"># this is where the icombiner function ends</span>

        <span class="c1"># close the input images</span>
        <span class="k">for</span> <span class="n">ifile</span> <span class="ow">in</span> <span class="n">imin</span><span class="p">:</span>
            <span class="n">image_close</span><span class="p">(</span><span class="n">ifile</span><span class="p">)</span>
        <span class="c1"># close the output images</span>
        <span class="k">for</span> <span class="n">ifile</span> <span class="ow">in</span> <span class="n">out</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ifile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">image_close</span><span class="p">(</span><span class="n">ifile</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logfd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logfd</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span></div>


<span class="k">def</span> <span class="nf">ic_stat</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">imref</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">offarr</span><span class="p">,</span> <span class="n">project</span><span class="p">,</span> <span class="n">nim</span><span class="p">,</span> <span class="n">masktype</span><span class="p">,</span>
            <span class="n">dothresh</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">domode</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># Determine the image section parameters.  This must be in terms of</span>
    <span class="c1"># the data image pixel coordinates though the section may be specified</span>
    <span class="c1"># in terms of the reference image coordinates.  Limit the number of</span>
    <span class="c1"># pixels in each dimension to a maximum.</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">imin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">project</span><span class="p">:</span>
        <span class="n">ndim</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">imin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

    <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>
    <span class="n">ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)[:</span><span class="n">ndim</span><span class="p">]</span>
    <span class="n">starts</span> <span class="o">=</span> <span class="n">starts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">ends</span> <span class="o">=</span> <span class="n">ends</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># XXX: implement this ic_section function</span>
    <span class="c1"># it&#39;s only active when statsec == &#39;overlap&#39;</span>
    <span class="c1"># seems to set va, vb, dv to be image from va to vb with step size dv</span>
    <span class="c1"># in each dimension. sticks with default of va = 0 (1 in IRAF),</span>
    <span class="c1"># vb = shape (length) of reference image, and dv = 1.</span>
    <span class="c1"># call ic_section (section, Memi[va], Memi[vb], Memi[dv], ndim)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">section</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;statsec: overlap not yet implemented.&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">oends</span> <span class="o">=</span> <span class="n">ends</span> <span class="o">*</span> <span class="mi">1</span>
    <span class="c1"># adjust based on the offsets, but be wary of the bounds</span>
    <span class="c1"># equivalent to v1 and v2 in IRAF in the 1-&gt;10 loop</span>
    <span class="n">starts</span> <span class="o">-=</span> <span class="n">offarr</span><span class="p">[</span><span class="n">nim</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">ends</span> <span class="o">-=</span> <span class="n">offarr</span><span class="p">[</span><span class="n">nim</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">starts</span><span class="p">[</span><span class="n">starts</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ends</span><span class="p">[</span><span class="n">ends</span> <span class="o">&gt;</span> <span class="n">oends</span><span class="p">]</span> <span class="o">=</span> <span class="n">oends</span><span class="p">[</span><span class="n">ends</span> <span class="o">&gt;</span> <span class="n">oends</span><span class="p">]</span>

    <span class="c1"># Accumulate the pixel values within the section.  Masked pixels and</span>
    <span class="c1"># thresholded pixels are ignored.</span>

    <span class="k">if</span> <span class="n">masktype</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;need to implement bad pixel masks in ic_stat&#39;</span><span class="p">)</span>
        <span class="c1"># need to carry in the pixel masks to this function,</span>
        <span class="c1"># then check that pixels aren&#39;t included in the masks before</span>
        <span class="c1"># adding them to the stats</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># NOTE: this may not work if project is True</span>
    <span class="c1"># get the subgrid of points we want</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">))</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="c1"># if we&#39;re dealing with masks, now would be the time to remove</span>
    <span class="c1"># points with bad pixel masks</span>

    <span class="c1"># now flatten down the data we want</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># remove points outside the threshold</span>
    <span class="k">if</span> <span class="n">dothresh</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">lower</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># this is going to break for things other than fits</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Image section contains no pixels: {imin.filename()}&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">mean</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># weird IRAF mode calculation is brute force slow even on modern</span>
    <span class="c1"># computers, so only do it if necessary</span>
    <span class="k">if</span> <span class="n">domode</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">ic_mode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">median</span><span class="p">,</span> <span class="n">mode</span>


<span class="k">def</span> <span class="nf">ic_mode</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">zrange</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">zstep</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">zbin</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">nmin</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute mode of an array.  The mode is found by binning</span>
<span class="sd">    with a bin size based on the data range over a fraction of the</span>
<span class="sd">    pixels about the median and a bin step which may be smaller than the</span>
<span class="sd">    bin size.  If there are too few points the median is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        Input array to calculate the mode</span>
<span class="sd">    zrange : float</span>
<span class="sd">        Fraction of pixels about median to use</span>
<span class="sd">    zstep : float</span>
<span class="sd">        Step size for search for mode</span>
<span class="sd">    zbin : float</span>
<span class="sd">        Bin size for mode.</span>
<span class="sd">    nmin : int</span>
<span class="sd">        Minimum number of pixels for mode calculation</span>
<span class="sd">    maxsize : int</span>
<span class="sd">        This function is crazy slow for limited use, so only use up to</span>
<span class="sd">        maxsize random points in this calculation. IRAF use 10k as the</span>
<span class="sd">        maxsize for the entire ic_stat function instead of just silly</span>
<span class="sd">        mode calculations.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float : mode of the input array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">maxsize</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">data</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="n">nn</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">nn</span> <span class="o">&lt;</span> <span class="n">nmin</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="n">ii</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">nn</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">zrange</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">))</span>
    <span class="n">jj</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nn</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">zrange</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">))</span>

    <span class="n">z1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">z1</span>

    <span class="n">zstep</span> <span class="o">=</span> <span class="n">zstep</span> <span class="o">*</span> <span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span>
    <span class="n">zbin</span> <span class="o">=</span> <span class="n">zbin</span> <span class="o">*</span> <span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span>

    <span class="n">z1</span> <span class="o">=</span> <span class="n">z1</span> <span class="o">-</span> <span class="n">zstep</span>
    <span class="n">kk</span> <span class="o">=</span> <span class="n">ii</span> <span class="o">*</span> <span class="mi">1</span>
    <span class="n">nmax</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">kk</span> <span class="o">&lt;</span> <span class="n">jj</span><span class="p">:</span>
        <span class="n">z1</span> <span class="o">+=</span> <span class="n">zstep</span>
        <span class="n">z2</span> <span class="o">=</span> <span class="n">z1</span> <span class="o">+</span> <span class="n">zbin</span>
        <span class="k">while</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">jj</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">z1</span><span class="p">:</span>
            <span class="n">ii</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">kk</span> <span class="o">&lt;</span> <span class="n">jj</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">z2</span><span class="p">:</span>
            <span class="n">kk</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">kk</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">&gt;</span> <span class="n">nmax</span><span class="p">:</span>
            <span class="n">nmax</span> <span class="o">=</span> <span class="n">kk</span> <span class="o">-</span> <span class="n">ii</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">ii</span> <span class="o">+</span> <span class="n">kk</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">mode</span>


<span class="k">def</span> <span class="nf">ic_gscale</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">dic</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">exptime</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">nimages</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">project</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stype</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
    <span class="k">elif</span> <span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;@&#39;</span><span class="p">:</span>
        <span class="n">stype</span> <span class="o">=</span> <span class="s1">&#39;file&#39;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Could not understand values in </span><span class="si">{param[1:]}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">nimages</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Insufficient values in </span><span class="si">{param[1:]}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">nimages</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Warning: Ignoring additional values in </span><span class="si">{param[1:]}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">values</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[:</span><span class="n">nimages</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;!&#39;</span><span class="p">:</span>
        <span class="n">stype</span> <span class="o">=</span> <span class="s1">&#39;keyword&#39;</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>
            <span class="n">hv</span> <span class="o">=</span> <span class="n">get_header_value</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">if</span> <span class="n">hv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">hv</span>
                <span class="k">if</span> <span class="n">project</span><span class="p">:</span>
                    <span class="n">values</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">hv</span>
                    <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">param</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
            <span class="n">stype</span> <span class="o">=</span> <span class="n">param</span>
            <span class="k">if</span> <span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;exposure&#39;</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">exptime</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">values</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.001</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Unknown scale, zero, or weight type: </span><span class="si">{param}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stype</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../index.html">AIRAF</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Ethan Kruse.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>